<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">
  <meta name="author" content="Thomas Weibel">
  <meta name="generator" content="GNU/Emacs">
  <link rel="shortcut icon" href="http://bigbird.comp.nus.edu.sg/pmwiki/pub/skins/beeblebrox2/images/favicon.ico">

  <!--HeaderText--><style type="text/css"><!--
  ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }
  code.escaped { white-space: nowrap; }
  .vspace { margin-top:1.33em; }
  .indent { margin-left:40px; }
  .outdent { margin-left:40px; text-indent:-40px; }
  a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
  a.createlink { text-decoration:none; position:relative; top:-0.5em;
    font-weight:bold; font-size:smaller; border-bottom:none; }
  img { border:0px; }
  
  .indent1 {margin-left:1.25em;}
  .indent2 {margin-left:2.5em;}
  .indent3 {margin-left:3.75em;}
  .indent4 {margin-left:5em;}  

  .toc1 {margin-left:1em;}
  .toc2 {margin-left:2em;}
  .toc3 {margin-left:3em;}
  .toc4 {margin-left:4em;}  

div.sectionedit { text-align:right;font-size:smaller;clear:both;}
.TCprogress {background-color:#5af;height:13px;width:13px;color:#fff}
table.TotalCounter td {font-size:x-small;text-align:center}.editconflict { color:green; 
  font-style:italic; margin-top:1.33em; margin-bottom:1.33em; }

  table.markup { border:2px dotted #ccf; width:90%; }
  td.markup1, td.markup2 { padding-left:10px; padding-right:10px; }
  table.vert td.markup1 { border-bottom:1px solid #ccf; }
  table.horiz td.markup1 { width:23em; border-right:1px solid #ccf; }
  table.markup caption { text-align:left; }
  div.faq p, div.faq pre { margin-left:2em; }
  div.faq p.question { margin:1em 0 0.75em 0; font-weight:bold; }
  div.faqtoc div.faq * { display:none; }
  div.faqtoc div.faq p.question 
    { display:block; font-weight:normal; margin:0.5em 0 0.5em 20px; line-height:normal; }
  div.faqtoc div.faq p.question * { display:inline; }
   
    .frame 
      { border:1px solid #cccccc; padding:4px; background-color:#f9f9f9; }
    .lfloat { float:left; margin-right:0.5em; }
    .rfloat { float:right; margin-left:0.5em; }
a.varlink { text-decoration:none; }

--></style>
  <link rel="stylesheet" href="tutorial_files/wsplus.html" type="text/css">
  <!--[if IE]><style type='text/css' media='screen'>
    body { behavior:url('http://bigbird.comp.nus.edu.sg/pmwiki/pub/wsplus/csshover.htc'); }
    .rollover * { visibility: visible; }
  </style><![endif]-->
  <meta name="robots" content="index,follow">


  <style type="text/css">
    @import url(http://bigbird.comp.nus.edu.sg/pmwiki/pub/skins/beeblebrox2/gila.css);
  </style>

  <!-- externalLinks(): to use rel='external' instead target='_blank' -->
  <script type="text/javascript">
    <!--
    function externalLinks() {
      if (!document.getElementsByTagName) return;
      var anchors = document.getElementsByTagName("a");
      for (var i=0; i<anchors.length; i++) {
        var anchor = anchors[i];
        if (anchor.getAttribute("href") &&
          anchor.getAttribute("rel") == "external")
            anchor.target = "_blank";
      }
    }
    window.onload = externalLinks;
    -->
  </script>
  <!-- /externalLinks() -->
  
  <title>Tutorial on Using DESPOT</title>
</head>

<body>

  <!-- Wiki header -->
  <div id="header">
	<img src="tutorial_files/banner.html">
  </div>

  <form id="headerSearch" action="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Site.Search">
    <div>
    <input name="pagename" value="Site/Search" type="hidden">
    <label for="searchbox">Search</label> 
    <input id="searchbox" class="searchbox" name="q" type="text">
    <input class="searchbutton" value="?" type="submit">
    </div>
  </form>
  <!-- /Wiki header -->
  
  
  
	<!-- Table Modification-->
	<table width="100%"><tbody><tr>
  
  
  
  <!-- Wiki navigation -->
  <!--PageLeftFmt-->
  <td class="wikileft">
    <div id="sidebar">
      <p></p><h1>
<a class="wikilink" href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Main.HomePage">Home</a></h1><p>
</p><p>Download
</p><div class="indent"><a class="wikilink" href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Main.Download">APPL Offline</a>
</div><div class="indent"><a class="wikilink" href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Main.DownloadDespot">APPL Online</a>
</div><div class="indent"><a class="wikilink" href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Main.DownloadMcvi">APPL Continuous</a>
</div><ul><li><a class="wikilink" href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Main.Repository">Dataset Respostiory</a>
</li><li><a class="wikilink" href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Main.PomdpXDocumentation">PomdpX File Format</a>
</li><li><a class="selflink" href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Main.PolicyXDocumentation">PolicyX File Format</a>
</li><li><a class="wikilink" href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Main.FAQ">APPL FAQ</a>
</li></ul><p class="vspace"></p><h1>
Change Log</h1><p>
</p><ul><li><a class="wikilink" href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Main.RecentChanges">RecentChanges</a>
</li><li><a class="wikilink" href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Site.AllRecentChanges">AllRecentChanges</a>
</li></ul><p class="vspace"></p><h1>
User Accouts</h1><p>
</p><ul><li><a class="wikilink" href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Main.PolicyXDocumentation?action=logout">Logout</a>
</li><li><a class="wikilink" href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Main.PolicyXDocumentation?action=pwchange">ChangePassword</a>
</li></ul><p class="vspace"></p><h1>
PmWiki Help</h1><p>
</p><ul><li><a class="wikilink" href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=PmWiki.DocumentationIndex">Documentation</a>
</li><li><a class="wikilink" href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=PmWiki.FAQ">FAQ</a>
</li><li><a class="urllink" href="http://www.pmwiki.org/wiki/Cookbook/HomePage" rel="nofollow">Cookbook</a>
</li></ul><p class="vspace" style="text-align: right;"> <span style="font-size:83%"><a class="wikilink" href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Site.SideBar?action=edit">edit SideBar</a></span>
</p>

    </div>
  </td>
  <!--/PageLeftFmt-->
  <!-- /Wiki navigation -->
  
  
  <!-- Wiki body -->
  <td id="wikibody">
    <!--PageHeaderFmt-->
    
    <!-- Wiki commands -->
    <div id="wikicmds">
      <a href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Main.PolicyXDocumentation?action=edit" accesskey="e">edit</a> ?
<a href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Main.PolicyXDocumentation?action=upload">upload</a> ?
<a href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Main.PolicyXDocumentation?action=diff" accesskey="h">history</a> ?
<a target="_blank" href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Main.PolicyXDocumentation?action=print" rel="external">print</a>
    </div>
    <!-- /Wiki commands -->
    
    <!--PageTitleFmt-->
    <div id="breadcrumbs">
      <a href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Main">Main</a> ? 
      <a href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Main.PolicyXDocumentation">DESPOT Tutorial</a>
    </div>
    <!--/PageTitleFmt-->

    <div id="wikipage">
 
<!--PageText-->
<div id="wikitext">
<!-- Include required JS files -->
<script type="text/javascript" src="js/shCore.js"></script>

<!-- 
	At least one brush, here we choose JS. You need to include a brush for
	every language you want to highlight
-->
<script type="text/javascript" src="css/shBrushCpp.js"></script>
<script type="text/javascript" src="css/shBrushBash.js"></script>

<!-- Include *at least* the core style and default theme -->
<link href="css/shCore.css" rel="stylesheet" type="text/css" />
<link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />

<!-- Finally, to actually run the highlighter, you need to include
this JS on your page -->
<script type="text/javascript">
SyntaxHighlighter.defaults.toolbar = false;
	SyntaxHighlighter.all()
</script>
	
	
<p></p>
<h1>Tutorial on Using DESPOT</h1><p style="margin-top: 0px;"></p>
<b>Table of Contents</b>
<div class="tocstyle">
<span class="toc1">
	1. <a href="#ntoc1">Overview</a></span><br>
<span class="toc1">
	2. <a href="#ntoc3">Coding a C++ Model</a></span><br>
<span class="toc2">
	2.1. <a href="#ntoc2.1">Problem</a></span><br>
<span class="toc3">
	2.1.1 <a href="#ntoc2.1.1">Using C++ Models</a></span><br>
<span class="toc2">
	2.2. <a href="#ntoc2.2">Essentials</a></span><br>
<span class="toc3">
	2.2.1 <a href="#ntoc2.2.1">States, Actions and Observations</a></span><br>
<span class="toc3">
	2.2.2 <a href="#ntoc2.2.2">Deterministic Simulative Model</a></span><br>
<span class="toc3">
	2.2.3 <a href="#ntoc2.2.3">Beliefs and Starting States</a></span><br>
<span class="toc3">
	2.2.4 <a href="#ntoc2.2.4">Bound-related Functions</a></span><br>
<span class="toc3">
	2.2.5 <a href="#ntoc2.2.5">Memory Management</a></span><br>
<span class="toc2">
	2.3. <a href="#ntoc2.3">Improving Performance</a></span><br>
<span class="toc3">
	2.3.1 <a href="#ntoc2.3.1">Custom Belief</a></span><br>
<span class="toc3">
	2.3.2 <a href="#ntoc2.3.2">Custom Bounds</a></span><br>
<span class="toc1">
	3. <a href="#ntoc3">References</a></span><br>
</div>

<h1><a name="ntoc1" id="ntoc1"></a>1. Overview</h1><p style="margin-top: 0px;"></p>
<div>
	DESPOT[<a href="#refDESPOT">1</a>] is an anytime online POMDP planning algorithm. To use our solver package, the user first need to represent the POMDP in one of the following two ways:
	<ul>
		<li> specify the POMDP in the POMDPX format as described in the <a href="">POMDPX documentation</a>, or
		<li> specify a deterministic simulative model [<a href="#refDESPOT">1</a>] for the POMDP in C++ according to the <code>DSPOMDP</code> interface included in the solver package (<a href="#ntoc3">Section 3</a>).
	</ul>
	Once a model is specified, the user can follow simple routines to use DESPOT to solve the POMDP (<a href="#ntoc2">Section 2</a>).
</div>

<div class="vspace">
	Which type of model is better? A POMDPX model requires relatively less programming, and some domain-independent bounds are provided to guide the policy search in DESPOT.
	However, POMDPX can only be used to represent POMDPs which are not very large, and an exact representation of the POMDP is needed.
	A C++ model may require more programming, but it comes with the full flexibility of integrating user's domain knowledge into the policy search process.
	In addition, it can represent extremely large problems, and only a black-box simulator &#8208; rather than an exact representation of the POMDP &#8208; is needed.
	To enjoy the full power of DESPOT, a C++ model is encouraged.
</div>

<div class="vspace">
	In this tutorial, we will work with a very simple POMDP problem. We first explain with illustration how DESPOT can solve a POMDP given its C++ model, and then explain how to code a C++ model for a POMDP. For how to use DESPOT to solve a POMDP specified in the POMDPX format, see README.txt in the DESPOT package.
</div>
</p>
</p>

<h1><a name="ntoc2" id="ntoc2"></a>2. Coding a C++ Model</h1><p style="margin-top: 0px;">
We explain and illustrate how a deterministic simulative model of a POMDP can be specified according to the <code>DSPOMDP</code> interface.
The ingredients are the following:
<ul>
	<li> representation of states, actions and observations,
	<li> the deterministic simulative model,
	<li> functions related to beliefs and starting states,
	<li> bound-related functions, and
	<li> memory management functions.
</ul>
We shall start with the minimal set of functions that need to be implemented in a C++ model (Section 2.2), and then explain how to implement additional functions which can be used to get better performance (Section 2.3).

<h2><a name="ntoc2.1" id="ntoc2.1"></a>2.1. Problem</h2><p style="margin-top: 0px;">
<div>
We will be using a simplified version of the <em>RockSample</em> problem [<a href='#refHSVI'>2</a>] as our running example. 
It is the same as the example used in the POMDPX documentation, but its description is included for the sake of completeness.
It models a rover on an exploration mission and it can achieve rewards
by sampling rocks in its immediate area. Consider a map of size 1 x 3 as
shown in Figure 1, with one rock at the left end and the terminal state at
the right end. The rover starts off at the center and its possible actions are
<em>A</em> = {<em>West</em>, <em>East</em>, <em>Sample</em>, <em>Check</em>}. 
</div>

<div class='vspace'><img width='450px' src='http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/uploads/Main/rockmap.jpg' alt='' title='' /><br /><strong>Figure 1.</strong> The 1 x 3 <em>RockSample</em> problem world. </div>
<p class='vspace'>As with the original version of the problem, the <em>Sample</em> action
samples the rock at the rover's current location. If the rock is good, the rover
receives a reward of 10 and the rock becomes bad. If the rock is bad, it receives a
penalty of &#8722;10. Moving into the terminal area yields a reward of 10. A penalty
of &#8722;100 is imposed for moving off the grid and sampling in a grid where there
is no rock. All other moves have no cost or reward. The <em>Check</em> action returns
a noisy observation from <em>O</em> = {<em>Good</em>, <em>Bad</em>}.
</p>

<h3><a name="ntoc2.1.1" id="ntoc2.1.1"></a>2.1.1 Using C++ Models</h2><p style="margin-top: 0px;">
DESPOT can also be used to solve a POMDP specified in C++ according to the <code>DSPOMDP</code> interface in the solver package.
Assume for now that a C++ model for the <em>RockSample</em> problem has been implemented as a class called <code>SimpleRockSample</code>, then the following code snippet shows how to use DESPOT to solve it. 

<div class='vspace'>
	<strong>Listing 1. Code snippet for running simulations using DESPOT</strong>
<pre class="brush:cpp">
DSPOMDP* model = new SimpleRockSample();
ScenarioLowerBound* lower_bound = model->CreateScenarioLowerBound();
ScenarioUpperBound* upper_bound = model->CreateScenarioUpperBound();

Solver* solver = new DESPOT(model, lower_bound, upper_bound);

Random random;
for (int run = 0; run < 100; run ++) {
	State* start_state = model->CreateStartState();
	Belief* belief = model->InitialBelief(start_state);
	solver->belief(belief);

	for (int step = 0; step < 90; step ++) {
		OBS_TYPE obs; double reward;

		int action = solver->Search();
		bool terminal = model->Step(*state, random.NextDouble(), action, reward, obs);

		if(terminal) break;

		solver->Update(action, obs);
	}
}
</pre>

In fact, the user only need to write something like the first line in the above code 
as the remaining snippet (and more) is already included in the <code>SimpleTUI</code> class in the solver package.
See Listing 2.
Command line options are parsed and stored in the object <code>Globals::config</code>. 
One can use <code>InitializeDefaultParameters</code> to set problem specific default values for the options.
A default option value will be overridden if it is set in command line.

<div class="vspace">
<strong>Listing 2. Code for running <code>DESPOT</code> on the <code>SimpleRockSample</code> model.</strong>
<pre class="brush:cpp">
class TUI: public SimpleTUI {
public:
  TUI() {
  }

  DSPOMDP* InitializeModel(option::Option* options) {
    DSPOMDP* model = new SimpleRockSample();
    return model;
  }

  /* Set problem specific default values for variables in Globals::config.*/
  void InitializeDefaultParameters() {
  }
};

int main(int argc, char* argv[]) {
  return TUI().run(argc, argv);
}
</pre>

The files needed for this example can be found in the problems/simple_rock_sample directory of the software package.
Running make in that directory will generate a binary <strong>simple_rs</strong>.
Simulations can then be done using the following command.

<div class="vspace">
<strong>Listing 3. Command for running simulations on the added model.</strong>
<pre class="brush:cpp">
simple_rs --runs &lt;N&gt; [OPTION]...
</pre>
</div>

<div class="vspace">
The above command performs N simulations. Each simulation consists of
iterations of online search and action execution. The search is done with
default discount factor of 0.95 and 500 scenarios. The initial state is
randomly drawn from the initial belief, and the simulation is terminated when
a terminal state is encountered or after a default of 90 steps. There are
various command line options that can be used, including specifying the discount 
factor, the maximum number of simulation steps, the search horizon.
Run <em>simple_rs --help</em> for available options with brief descriptions.
</div>

<div class="vspace">
By default, the software prints out some useful information on the simulations for the user. 
For example, the software prints out the initial world state, and at each step, it also 
prints out the action, current world state, observation, observation probability, one step 
reward, current total discounted reward and current total undiscounted reward.
These outputs can be silenced by using the command line option <strong>--silence</strong>. 
When coding a model, these outputs are pretty useful for checking correctness.
In addition, more outputs can be generated using the <strong>--verbosity</strong> or <strong>-v</strong> option.
There are 6 different levels of verbosity: NONE, WARN, ERROR, INFO, DEBUG, VERBOSE, which correpond to values from 0 to 5 respectively.
The default verbosity level is 0 (NONE).
</div>

<h2><a name="ntoc2.2" id="ntoc2.2"></a>2.2. Essentials</h2><p style="margin-top: 0px;"></p>
The following code snippet shows the essential functions in the <code>DSPOMDP</code> interface.
<b>Note that we do not cover functions that have to be implemented (pure virtual) but are not required by the solver to work correctly, such as the <code>PrintAction</code> and <code>PrintState</code> in the <code>DSPOMDP</code> class.</b>

<div class='vspace'>
<strong>Listing 4. Essential functions in the DSPOMDP interface</strong>
<pre class="brush:cpp">
class DSPOMDP { 
public:
	/* Returns total number of actions.*/
	virtual int NumActions() const = 0;

	/* Deterministic simulative model.*/
	virtual bool Step(State& state, double random_num, int action,
		double& reward, OBS_TYPE& obs) const = 0;

	/* Functions related to beliefs and starting states.*/
	virtual double ObsProb(OBS_TYPE obs, const State& state, int action) const = 0;
	virtual Belief* InitialBelief(const State* start, string type = "DEFAULT") const = 0;
	virtual State* CreateStartState(string type = "DEFAULT") const = 0;

	/* Bound-related functions.*/
	virtual double GetMaxReward() const = 0;
	virtual ValuedAction GetMinRewardAction() const = 0;

	/* Memory management.*/
	virtual State* Allocate(int state_id, double weight) const = 0;
	virtual State* Copy(const State* particle) const = 0;
	virtual void Free(State* particle) const = 0;
};
</pre>
</div>

The following declaration of the <code>SimpleRockSample</code> class implements the above <code>DSPOMDP</code> interface. 
It is the same as the <code>DSPOMDP</code> interface except that the functions are no longer pure virtual, and a <code>MemoryPool</code> object is declared for memory management. 
We explain the functions and their implementation in detail in the following paragraphs.

<div class='vspace'>
<strong>Listing 5. Declaration of the SimpleRockSample class</strong>
<pre class="brush:cpp">
class SimpleRockSample : public DSPOMDP { 
public:
	/* Returns total number of actions.*/
	int NumActions() const;

	/* Deterministic simulative model.*/
	bool Step(State& state, double random_num, int action,
		double& reward, OBS_TYPE& obs) const;

	/* Functions related to beliefs and starting states.*/
	double ObsProb(OBS_TYPE obs, const State& state, int action) const;
	Belief* InitialBelief(const State* start, string type = "DEFAULT") const;
	State* CreateStartState(string type = "DEFAULT") const;

	/* Bound-related functions.*/
	virtual double GetMaxReward() const;
	virtual ValuedAction GetMinRewardAction() const;

	/* Memory management.*/
	State* Allocate(int state_id, double weight) const;
	State* Copy(const State* particle) const;
	void Free(State* particle) const;
	int NumActiveParticles() const;

private:
	mutable MemoryPool&lt;SimpleState&gt; memory_pool_;
}
</pre>
</div>

<h3><a name="ntoc2.2.1" id="ntoc2.2.1"></a>2.2.1. States, Actions and Observations</h3><p style="margin-top: 0px;">
<div>
A state is required to be represented as an instance of the <code>State</code> class or its subclass.
The generic state class inherits <code>MemoryObject</code> for memory management, as will be discussed more later.
It has two member variables: <code>state_id</code> and <code>weight</code>.
The former is useful when dealing with simple discrete POMDPs, and the latter is used when using the <code>State</code> object to represent a weighted particle.

<div class="vspace">
<strong>Listing 6. The generic state class</strong>
<pre class="brush:cpp">class State : public MemoryObject {
public:
	int state_id;
	double weight;

	State(int _state_id = -1, double _weight = 0.0) :
		state_id(_state_id),
		weight(_weight) {
	}

	virtual ~State() {
	}
};
</pre>
</div>

<div class='vspace'>
For <code>SimpleRockSample</code>, we can actually use the generic state class to represent its states by mapping each state to an integer, but we define customized state class so as to illustrate how this can be done.
</div>

<div class='vspace'>
<strong>Listing 7. The state class for <code>SimpleRockSample</code></strong>
<pre class="brush:cpp">
class SimpleState : public State {
public:
	int rover_position; // takes value 0, 1, 2 starting from the leftmost grid
	int rock_status; // indicates whether the rock is good

	SimpleState() {
	}

	SimpleState(int _rover_position, int _rock_status) : 
		rover_position(_rover_position),
		rock_status(_rock_status) {
	}

	~SimpleState() {
	}
};
</pre>
</div>

<div class='vspace'>
Actions are represented as consecutive integers of <code>int</code> type starting from 0, and the user is required to implement the 
<code>NumActions()</code> function which returns the total number of actions. 

<div class='vspace'>
<strong>Listing 8. Implementation of <code>NumActions()</code> for <code>SimpleRockSample</code>.</strong>
<pre class="brush:cpp">
int SimpleRockSample::NumActions() const {
	return 4; 
}
</pre>
</div>

For the sake of readability, we shall use an <code>enum</code> to represent actions for <code>SimpleRockSample</code>
<div class='vspace'>
<strong>Listing 9. Action enum for <code>SimpleRockSample</code></strong>
<pre class="brush:cpp">
enum {
	A_SAMPLE = 0,
	A_EAST = 1,
	A_WEST = 2,
	A_CHECK = 3
};
</pre>
</div>

<div class='vspace'>
Observations are represented as integers of type <code>uint64_t</code>, which is also named as <code>OBS_TYPE</code> using <code>typedef</code>.
Unlike the actions, the set of observations need not be consecutive integers.
For <code>SimpleRockSample</code>, we use an <code>enum</code> to represent the observations as well.
</div>

<div class='vspace'>
<strong>Listing 10. Observation enum for <code>SimpleRockSample</code></strong>
<pre class="brush:cpp">
enum {
	O_BAD = 0,
	O_GOOD = 1,
};
</pre>
</div>

<h3><a name="ntoc2.2.2" id="ntoc2.2.2"></a>2.2.2. Deterministic Simulative Model</h3><p style="margin-top: 0px;"></p>

A deterministic simulative model for a POMDP is a function <em>g(s, a, r) = &lt;s', o&gt;</em> such that when <em>r</em> is randomly distributed in <em>[0,1]</em>, <em>&lt;s', o&gt</em> is distributed according to <em>P(s', o | s, a)</em>. 
The deterministic simulative model is implemented in the <code>Step</code> function.
The argument names are self-explanatory, but note that 
<ul>
<li> there is a single <code>State</code> object which is used to represent both <em>s</em> and <em>s'</em>,
<li> the reward function is also implemented,
<li> the function returns true iff executing <em>a</em> on <em>s</em> results in a terminal state.
</ul>

<div class="vspace">
<strong>Listing 11. A deterministic simulative model for SimpleRockSample</strong>
<pre class="brush:cpp">
bool SimpleRockSample::Step(State&amp; state, double rand_num, int action,
		double&amp; reward, OBS_TYPE&amp; obs) const {
	SimpleState&amp; simple_state = static_cast&lt;SimpleState&&gt;(state);
	int& rover_position = simple_state.rover_position;
	int& rock_status = simple_state.rock_status;

	if (rover_position == 0) {
		if (action == A_SAMPLE) {
			reward = (rock_status == R_GOOD) ? 10 : -10;
			obs = O_GOOD;
			rock_status = R_BAD;
		} else if (action == A_CHECK) {
			reward = 0;
			obs = (rock_status == R_GOOD) ? O_GOOD : O_BAD;
		} else if (action == A_WEST) {
			reward = -100;
			obs = O_GOOD;
			rover_position = 2;
		} else {
			reward = 0;
			obs = O_GOOD;
			rover_position = 1;
		}
	} else if (rover_position  == 1) {
		if (action == A_SAMPLE) {
			reward = -100;
			obs = O_GOOD;
			rover_position = 2;
		} else if (action == A_CHECK) {
			reward = 0;
			obs =  (rand_num &gt; 0.20) ? rock_status : (1 - rock_status);
		} else if (action == A_WEST) {
			reward = 0;
			obs = O_GOOD;
			rover_position = 0;
		} else {
			reward = 10;
			obs = O_GOOD;
			rover_position = 2;
		}
	} else {
		reward = 0;
		obs = O_GOOD;
	}

	return rover_position == 2;
}
</pre>
</div>

<h3><a name="ntoc2.2.3" id="ntoc2.2.3"></a>2.2.2. Beliefs and Starting States</h3><p style="margin-top: 0px;"></p>

Our solver package supports arbitrary belief representation: The user can implement their own belief representation by implementing the <code>Belief</code> interface, which is only required to support sampling of particles, and belief update. 
The solver package comes with SIR (<a href="http://en.wikipedia.org/wiki/Particle_filter">sequential importance resampling</a>) particle filter as the default belief representation, which is implemented in the <code>ParticleBelief</code> class.
The <code>ObsProb</code> function is required in <code>ParticleBelief</code> for belief update.
It implements the observation function in a POMDP, that is, it computes the probability of observing <code>obs</code> given current state <code>state</code> resulting from executing an action <code>action</code> in previous state.

<div class="vspace">
<strong>Listing 12. Observation function for <code>SimpleRockSample</code></strong>
<pre class="brush:cpp">
double SimpleRockSample::ObsProb(OBS_TYPE obs, const State&amp; state, int action) const {
	if (action == A_CHECK) {
		const SimpleState&amp; simple_state = static_cast&lt;const SimpleState&&gt;(state);
		int rover_position = simple_state.rover_position;
		int rock_status = simple_state.rock_status;
		if (rover_position == LEFT) {
			return obs == rock_status;
		} else if (rover_position == MIDDLE) {
			return (obs == rock_status) ? 0.8 : 0.2;
		}
	} else {
		return obs == O_GOOD;
	}
}
</pre>
</div>

The following code shows how the initial belief for <code>SimpleRockSample</code> can be represented by <code>ParticleBelief</code>.
This example does not use the arguments, but in general, one can use <code>start</code> to pass partial information about the starting state to the initial belief, and use <code>type</code> to select different types of initial beliefs (such as uniform belief, or skewed belief), where <code>type</code> is specified using the command line option <strong>--belief</strong> or <strong>-b</strong>, with a value of "DEFAULT" if left unspecified. 

<div class="vspace">
<strong>Listing 13. Initial belief for <code>SimpleRockSample</code></strong>
<pre class="brush:cpp">
Belief* SimpleRockSample::InitialBelief(const State* start, string type) const {
		vector&lt;State*&gt; particles;

		if (type == "DEFAULT" || type == "PARTICLE") {
			SimpleState* good_rock = static_cast&lt;SimpleState*&gt;(Allocate(-1, 0.5));
			good_rock-&gt;rover_position = 1;
			good_rock-&gt;rock_status = 1;
			particles.push_back(good_rock);

			SimpleState* bad_rock = static_cast&lt;SimpleState*&gt;(Allocate(-1, 0.5));
			bad_rock-&gt;rover_position = 1;
			bad_rock-&gt;rock_status = 0;
			particles.push_back(bad_rock);

			return new ParticleBelief(particles, this);
		} else {
			cerr &lt&lt "Unsupported belief type: " &lt&lt type &lt&lt endl;
			exit(1);
		}
}
</pre>
</div>

The <code>CreateStartState</code> function is used to sample starting states in simulations.
The starting state is generally sampled from the initial belief, but it may be sampled from a different distribution in some problems.
Users may use the argument <code>type</code> to choose how the starting state is sampled.
<div class="vspace">
<strong>Listing 14. Sample a starting state from the initial belief for <code>SimpleRockSample</code></strong>
<pre class="brush:cpp">
State* SimpleRockSample::CreateStartState(string type) const {
  return new SimpleState(1, Random::RANDOM.NextInt(2)));
}  
</pre>
</div>

<h3><a name="ntoc2.2.4" id="ntoc2.2.4"></a>2.2.4. Bound-related Functions</h3><p style="margin-top: 0px;"></p>
<div>
The heuristic search in DESPOT needed to be guided by upper and lower bounds on 
the infinite-horizon value that can be obtained on a set of scenarios.
The <code>DSPOMDP</code> interface requires implementing the
<code>GetMinRewardAction</code> function and the <code>GetMaxReward</code> function
to construct the simplest such bounds.
</div>

<div class='vspace'>
The <code>GetMinRewardAction</code> function returns <em>(a, v)</em>, where <em>a</em> is an action with largest minimum reward when it is executed, and <em>v</em> is its minimum reward.
The minimum infinite-horizon value that can be obtained on a set of scenarios with total weight <em>W</em> is then bounded below by
<em>Wv / (1 - &gamma;)</em>, where <em>&gamma;</em> is the discount factor.
</div>

<div class="vspace">
<strong>Listing 15. Implementation of <code>GetMinRewardAction</code> for <code>SimpleRockSample</code></strong>
<pre class="brush:cpp">
ValuedAction SimpleRockSample::GetMinRewardAction() const {
    return ValuedAction(A_EAST, 0);
}
</pre>
</div>

<div class='vspace'>
The <code>GetMaxReward</code> function returns the maximum possible reward <em>R<sub>max</sub></em> in a step, and 
the maximum infinite-horizon value that can be obtained on a set of scenarios with total weight <em>W</em> is then bounded above by
<em>W R<sub>max</sub> / (1 - &gamma;)</em>, where <em>&gamma;</em> is the discount factor.
</div>

<div class="vspace">
<strong>Listing 16. Implementation of <code>GetMaxReward</code> for <code>SimpleRockSample</code></strong>
<pre class="brush:cpp">
double SimpleRockSample::GetMaxReward() const {
    return 10;
}
</pre>

<h3><a name="ntoc2.2.5" id="ntoc2.2.5"></a>2.2.5 Memory Management</h3><p style="margin-top: 0px;">

DESPOT requires the creation of many <code>State</code> objects during the search.
The creation and destruction of these objects are expensive, so they are done using the <code>Allocate</code>, <code>Copy</code>, and <code>Free</code> functions to allow users to provide their own memory management mechanisms to make these operations less expensive.
We provide a solution method based on the memory management technique in David Silver's <a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Applications.html">implementation</a> of the POMCP algorithm.
The idea is to create new <code>State</code> objects in chunks (instead of one at a time), and put objects in a free list for recycling when they are no longer needed (instead of deleting them).
The following code serves as a template of how this can be done.

<div class="vspace">
<strong>Listing 17. Memory management functions for <code>SimpleRockSample</code>.</strong>
<pre class="brush:cpp">
State* SimpleRockSample::Allocate(int state_id, double weight) const {
    SimpleState* state = memory_pool_.Allocate();
    state-&gt;state_id = state_id;
    state-&gt;weight = weight;
    return state;
}

State* SimpleRockSample::Copy(const State* particle) const {
    SimpleState* state = memory_pool_.Allocate();
    *state = *static_cast&lt;const SimpleState*>(particle);
    state-&gt;SetAllocated();
    return state;
}

void SimpleRockSample::Free(State* particle) const {
    memory_pool_.Free(static_cast&lt;SimpleState*&gt;(particle));
}
</pre>

<b>Note: <code>Copy</code> should return a deep copy of the particle. If the particle contains a pointer, the default assignment operator = does not work, because the pointers in the original particle and its copy will point to the same content. Avoid the use of pointers in a <code>State</code> class to simplify implementation, or provide your own code for making deep copies if you have to use pointers.</b>

<h2><a name="ntoc2.3" id="ntoc2.3"></a>2.3. Improving Performance</h2><p style="margin-top: 0px;"></p>
Accurate belief tracking and good bounds are important for getting good performance. 
An important feature of the DESPOT software package is the flexibility that it provides for defining custom beliefs and custom bounds.
This will be briefly explained below.

<h3><a name="ntoc2.3.1" id="ntoc2.3.1"></a>2.3.1 Custom Belief</h3><p style="margin-top: 0px;">
The solver package can work with any belief representation implementing the abstract <code>Belief</code> interface.
A concrete belief class need to implement two functions:
the <code>Sample</code> function returns a number of particles sampled from the belief, and the <code>Update</code> function updates the belief after executing an action and receiving an observation.
To allow the solver to use a custom belief, create it using the <code>InitialBelief</code> function in the <code>DSPOMDP</code> class. See src/problems for examples.

<pre class="brush:cpp">
class Belief {
public:
	Belief(const DSPOMDP* model);

	virtual vector&ltState*&gt Sample(int num) const = 0;
	virtual void Update(int action, OBS_TYPE obs) = 0;
};
</pre>

<h3><a name="ntoc2.3.2" id="ntoc2.3.2"></a>2.3.2 Custom Bounds</h3><p style="margin-top: 0px;">
<div>
The lower and upper bounds mentioned in the previous section are non-informative
and generally only works for simple problems.
This section gives a brief explanation on how users can create their own bounds.
We shall focus on the lower bounds.
Creating an upper bound is similar, and examples can be found in the code in the 
<a href="#ntoc5">appendix</a>.
</div>

<div class='vspace'>
A new type of lower bound is defined as a child class of the <code>ScenarioLowerBound</code> class shown in Listing 20.
A <code>ScenarioLowerBound</code> object computes a lower bound for the 
infinite-horizon value of a set of weighted scenarios (as determined by the 
particles and the random number streams) given the action-observation history.
The first action that need to be executed in order to achieve the lower bound value is also returned together with the value, using a <code>ValuedAction</code> object.
The random numbers used in the scenarios are reprensented using a <code>RandomStreams</code> object. 
A <code>ScenarioLowerBound</code> bound objects also return 
<div class='vspace'>
<b> Listing 20. The <code>ScenarioLowerBound</code> interface</b>
<pre class="brush:cpp">
class ScenarioLowerBound {
protected:
	const DSPOMDP* model_;

public:
	ScenarioLowerBound(const DSPOMDP* model);

	/**
	 * Returns a lower bound to the maximum total discounted reward over an
	 * infinite horizon for the weighted scenarios.
	 */
	virtual ValuedAction Value(const vector&lt;State*&gt;& particles,
		RandomStreams& streams, History& history) const = 0;
};
</pre>
</div>

<div class="vspace">
Two types of lower bounds are often used: <code>ParticleLowerBound</code> and <code>Policy</code>.
A <code>ParticleLowerBound</code> simply ignores the random numbers in the scenarios, and computes a lower bound for the 
infinite-horizon value of a set of weighted particles given the action-observation history.
A <code>Policy</code> defines a policy mapping from the scenarios/history to an action, and runs this policy 
on the scenarios to obtain a lower bound.
The random number streams only has finite length, and a 
<code>Policy</code> uses a <code>ParticleLowerBound</code> to 
estimate a lower bound on the scenarios when all the random numbers have been
consumed.
</div>

<div class="vspace">
<strong>Listing 18. The <code>ParticleLowerBound</code> interface</strong>
<pre class="brush:cpp">
class ParticleLowerBound : public ScenarioLowerBound {
public:
	ParticleLowerBound(const DSPOMDP* model);

	/**
	 * Returns a lower bound to the maximum total discounted reward over an
	 * infinite horizon for the weighted particles.
	 */
	virtual ValuedAction Value(const vector&lt;State&gt;&amp; particles) const = 0;
};
</pre>
</div>

<div class='vspace'>
<strong>Listing 19. Code snippet from the <code>Policy</code> class.</strong>
<pre class="brush:cpp">
class Policy : public ScenarioLowerBound {
public:
	Policy(const DSPOMDP* model, ParticleLowerBound* bound, Belief* belief = NULL);
	virtual ~Policy();

	virtual int Action(const vector&lt;State*&gt;&amp; particles,
		RandomStreams&amp; streams, History&amp; history) const = 0;
};
</pre>
</div>

<div class='vspace'>
As an example of a <code>Policy</code>, the following code implements a simple fixed-action policy for
<code>SimpleRockSample</code>.
</div>
<div class="vspace">
<strong>Listing 20. A simple fixed-action policy for <code>SimpleRockSample</code>.</strong>
<pre class="brush:cpp">
class SimpleRockSampleEastPolicy : public policy {
	public:
		SimpleRockSampleEastPolicy(const DSPOMDP* model, ParticleLowerBound* bound)
			: Policy(model, bound){}

		int Action(const vector&lt;State*&gt;&amp; particles,
				RandomStreams&amp; streams, History&amp; history) const {
			return 1; // move east
		}
};
</pre>
</div>

<div class='vspace'>
The <code>DSPOMDP</code> interface allows user-defined lower bounds to be easily added by
overriding the <code>CreateScenarioLowerBound</code> function in the <code>DSPOMDP</code> interface.
The default implementation of <code>CreateScenarioLowerBound</code> only supports the creation of the 
<code>TrivialParticleLowerBound</code>, which returns the lower bound as generated 
using <code>GetMinRewardAction</code>.
</div>

<div class='vspace'>
<strong>Listing 21. <code>DSPOMDP</code> code related to supporting user-defined lower bounds.</strong>
<pre class='brush:cpp'>
class DSPOMDP {
public:
	virtual ScenarioLowerBound* CreateScenarioLowerBound(string name = "DEFAULT",
	  string particle_bound_name = "DEFAULT") {
		if (name == "TRIVIAL" || name == "DEFAULT") {
			scenario_lower_bound_ = new TrivialParticleLowerBound(this);
		} else {
			 cerr &lt;&lt; "Unsupported scenario lower bound: " &lt;&lt; name &lt;&lt; endl;
			 exit(0);
		}
	}
};
</pre>
</div>

<div class='vspace'>
The following code adds this lower bound to <code>SimpleRockSample</code> and sets it as 
the default scenario lower bound.
</div>

<div class="vspace">
<strong>Listing 22. Adding <code>SimpleRockSampleEastPolicy</code>.</strong>
<pre class="brush:cpp">
ScenarioLowerBound* SimpleRockSample::CreateScenarioLowerBound(string name = "DEFAULT",
  string particle_bound_name = "DEFAULT") {
	if (name == "TRIVIAL") {
		scenario_lower_bound_ = new TrivialParticleLowerBound(this);
	} else if (name == "EAST" || name == "DEFAULT") {
		scenario_lower_bound_ = new SimpleRockSampleEastPolicy(this,
		  new TrivialParticleLowerBound(this));
	} else {
		cerr &lt;&lt; "Unsupported lower bound algorithm: " &lt;&lt; name &lt;&lt; endl;
		exit(0);
	}
}
</pre>
</div>


<div class='vspace'>
Once a lower bound is added, and the solver package is recompiled, then users can choose to 
use it when running simple_rs by setting the <b>-l</b> option or the <b>--plb</b> option.
For example, both of the following commands use <code>SimpleRockSampleEastPolicy</code>.
</div>

<div class='vspace'>
<pre class="brush:cpp">
simple_rs --runs 100
simple_rs --runs 100 -l EAST
</pre>
</div>

<h1><a name="ntoc3" id="ntoc3"></a>3. References</h1><p style="margin-top: 0px;"></p>
<p><a name='refHSVI' id='refDESPOT'></a>[1] A. Somani and N. Ye and D. Hsu and W.S. Lee. DESPOT: Online POMDP Planning with Regularization. In Advances In Neural Information Processing Systems, 2013.</p>
<p><a name='refHSVI' id='refHSVI'></a>[2] T. Smith and R. Simmons. Heuristic Search Value Iteration for POMDPs. In Proc. Uncertainty in Artificial Intelligence, 2004.</p>
		
<div class="vspace"></div>

    </div>
  </td>
  <!-- /Wiki body -->
  
  
  
  	</tr></tbody></table>
	<!-- /Table Modification-->
  
  
  
  <!-- Wiki footer -->
  <!--PageFooterFmt-->
  <div id="wikifoot">
    <div class="footnav">
      <a href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Main.PolicyXDocumentation?action=$LoginAction" accesskey="l">$LoginAction</a> ?
      <a href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Main.PolicyXDocumentation?action=edit" accesskey="e">edit</a> ?
<a href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Main.PolicyXDocumentation?action=upload">upload</a> ?
<a href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Main.PolicyXDocumentation?action=diff" accesskey="h">history</a> ?
<a target="_blank" href="http://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/index.php?n=Main.PolicyXDocumentation?action=print" rel="external">print</a>
    </div>

    <div class="lastmod">
      Page last modified on February 04, 2010, at 06:06 PM
    </div>

    <div class="copyright">
      &nbsp;
    </div>
  </div>
  <!--/PageFooterFmt-->
  <!-- /Wiki footer -->



</body></html>
